#include <ros/ros.h>
#include <nav_msgs/OccupancyGrid.h>
#include <nav_msgs/Path.h>
#include <visualization_msgs/Marker.h>
#include <queue>

struct Node {
    int x, y;
    int f, g, h;
    Node* parent;
    Node(int _x, int _y, int _f, int _g, int _h, Node* _p) : x(_x), y(_y), f(_f), g(_g), h(_h), parent(_p) {}
};

class AstarPlanner {
private:
    ros::NodeHandle nh_;
    ros::Subscriber map_sub_;
    ros::Publisher path_pub_, marker_pub_;
    nav_msgs::OccupancyGrid map_;
    bool map_received_;
public:
    AstarPlanner() : map_received_(false) {
        map_sub_ = nh_.subscribe<nav_msgs::OccupancyGrid>("map", 1, &AstarPlanner::mapCallback, this);
        path_pub_ = nh_.advertise<nav_msgs::Path>("path", 1);
        marker_pub_ = nh_.advertise<visualization_msgs::Marker>("visualization_marker", 1);
    }

    void mapCallback(const nav_msgs::OccupancyGridConstPtr& msg) {
        map_ = *msg;
        map_received_ = true;
    }

    std::vector<Node*> neighborNodes(Node* curr) {
        std::vector<Node*> neighbors;
        int dx[] = {-1, 0, 1, 0};
        int dy[] = {0, -1, 0, 1};
        for (int i=0; i<4; i++) {
            int nx = curr->x + dx[i];
            int ny = curr->y + dy[i];
            if (nx < 0 || nx >= map_.info.width || ny < 0 || ny >= map_.info.height)
                continue;
            int index = ny * map_.info.width + nx;
            if (map_.data[index] == 100)  // 障碍物
                continue;
            int g = curr->g + abs(dx[i]) + abs(dy[i]);  // 计算新的g值
            int h = abs(nx - goal_x_) + abs(ny - goal_y_);  // 计算新的h值
            int f = g + h;  // 计算新的f值
            Node* neighbor = new Node(nx, ny, f, g, h, curr);
            neighbors.push_back(neighbor);
        }
        return neighbors;
    }

    bool isGoal(Node* node) {
        return node->x == goal_x_ && node->y == goal_y_;
    }

    void publishPath(std::vector<Node*>& path_nodes) {
        nav_msgs::Path path;
        path.header.stamp = ros::Time::now();
        path.header.frame_id = "map";
        for (int i=path_nodes.size()-1; i>=0; i--) {
            geometry_msgs::PoseStamped pose;
            pose.pose.position.x = (path_nodes.at(i)->x + 0.5) * map_.info.resolution + map_.info.origin.position.x;
            pose.pose.position.y = (path_nodes.at(i)->y + 0.5) * map_.info.resolution + map_.info.origin.position.y;
            pose.pose.orientation.w = 1.0;
            path.poses.push_back(pose);
        }
        path_pub_.publish(path);

        // 显示路径的可视化Marker
        visualization_msgs::Marker marker;
        marker.header.frame_id = "map";
        marker.header.stamp = ros::Time::now();
        marker.ns = "path";
        marker.id = 0;
        marker.type = visualization_msgs::Marker::LINE_STRIP;
        marker.action = visualization_msgs::Marker::ADD;
        marker.pose.orientation.w = 1.0;
        marker.scale.x = 0.1;
        marker.color.r = 1.0;
        marker.color.a = 1.0;
        for (int i=path_nodes.size()-1; i>=0; i--) {
            geometry_msgs::Point point;
            point.x = (path_nodes.at(i)->x + 0.5) * map_.info.resolution + map_.info.origin.position.x;
            point.y = (path_nodes.at(i)->y + 0.5) * map_.info.resolution + map_.info.origin.position.y;
            point.z = 0.0;
            marker.points.push_back(point);
        }
        marker_pub_.publish(marker);
    }

    void plan(int start_x, int start_y, int goal_x, int goal_y) {
        if (!map_received_) {
            ROS_WARN("Map has not been received yet. Unable to plan.");
            return;
        }
        goal_x_ = goal_x;
        goal_y_ = goal_y;

        std::priority_queue<Node*, std::vector<Node*>, [](Node* a, Node* b) {return a->f > b->f;}> open;  // A* open队列
        std::vector<Node*> closed;  // A* closed列表
        Node* start = new Node(start_x, start_y, 0, 0, 0, nullptr);
        open.push(start);

        while (!open.empty()) {
            Node* curr = open.top();
            open.pop();
            if (isGoal(curr)) {
                std::vector<Node*> path_nodes;  // 存储从起点到终点的路径节点
                while (curr != nullptr) {
                    path_nodes.push_back(curr);
                    curr = curr->parent;
                }
                publishPath(path_nodes);
                break;
            }
            std::vector<Node*> neighbors = neighborNodes(curr);
            for (Node* neighbor : neighbors) {
                bool alreadyInClosed = false;
                for (Node* closed_node : closed) {
                    if (neighbor->x == closed_node->x && neighbor->y == closed_node->y) {
                        alreadyInClosed = true;
                        break;
                    }
                }
                if (alreadyInClosed)
                    continue;
                bool alreadyInOpen = false;
                for (Node* open_node : open._Get_container()) {
                    if (neighbor->x == open_node->x && neighbor->y == open_node->y) {
                        alreadyInOpen = true;
                        if (neighbor->g < open_node->g) {
                            open_node->g = neighbor->g;
                            open_node->f = open_node->g + open_node->h;
                            open_node->parent = neighbor->parent;
                        }
                        break;
                    }
                }
                if (!alreadyInOpen) {
                    open.push(neighbor);
                }
            }
            closed.push_back(curr);
        }

        // 释放内存
        for (Node* node : closed) {
            delete node;
        }
        while (!open.empty()) {
            Node* node = open.top();
            open.pop();
            delete node;
        }
    }

private:
    int goal_x_;
    int goal_y_;
};

int main(int argc, char** argv) {
    ros::init(argc, argv, "astar_planner");
    AstarPlanner astar_planner;
    ros::Rate rate(10.0);

    // 获取起点和终点坐标
    int start_x, start_y;
    int goal_x, goal_y;
    ROS_INFO("Please input the start point x and y coordinates (separate with space):");
    std::cin >> start_x >> start_y;
    ROS_INFO("Please input the goal point x and y coordinates (separate with space):");
    std::cin >> goal_x >> goal_y;

    while (ros::ok()) {
        ros::spinOnce();

        // 进行路径规划
        astar_planner.plan(start_x, start_y, goal_x, goal_y);

        rate.sleep();
    }

    return 0;
}
