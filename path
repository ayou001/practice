#include <ros/ros.h>
#include <nav_msgs/OccupancyGrid.h>
#include <geometry_msgs/PoseStamped.h>
#include <tf/transform_datatypes.h>
#include <iostream>
#include <vector>
#include <cmath>
#include <queue>
#include <algorithm>

// 定义节点类，用于存储搜索过程中的节点信息
class Node
{
public:
    int x;
    int y;
    double g;  // 节点到起点的代价
    double f;  // 估计代价函数值：f=g+h
    Node* parent;

    Node(int x_, int y_, double g_, Node* parent_)
        :x(x_), y(y_), g(g_), f(0), parent(parent_)
    {}

    // 定义启发函数heuristic：计算该节点到终点的曼哈顿距离
    static double heuristic(const Node* a, const Node* b)
    {
        // 曼哈顿距离=横向距离+纵向距离
        return std::abs(a->x - b->x) + std::abs(a->y - b->y);
    }
};

// 定义Hybrid A*路径规划器类
class HybridAstarPlanner
{
private:
    ros::NodeHandle nh_;
    ros::Subscriber map_sub_;
    ros::Publisher path_pub_;
    const double resolution_;
    const int map_origin_x_;
    const int map_origin_y_;
    std::vector<int8_t> map_data_;
    int map_width_;
    int map_height_;
    // 定义地图尺寸和障碍物坐标
    const int map_size_x_;
    const int map_size_y_;
    std::vector<std::pair<int, int>> obstacles_;

public:
    HybridAstarPlanner()
        :resolution_(0.1), map_origin_x_(-10), map_origin_y_(-15),
         map_size_x_(20), map_size_y_(30),
         obstacles_{{2,5},{3,5},{4,5},{5,5},{6,5},{7,5},{8,5},
                    {12,15},{13,15},{14,15},{15,15}}
    {
        // 订阅地图信息
        map_sub_ = nh_.subscribe("/map", 1, &HybridAstarPlanner::mapCallback, this);
        // 发布路径信息
        path_pub_ = nh_.advertise<nav_msgs::Path>("path", 1);
    }

    // 地图回调函数，将地图信息存储到map_data_中
    void mapCallback(const nav_msgs::OccupancyGrid& msg)
    {
        map_width_ = msg.info.width;
        map_height_ = msg.info.height;
        map_data_ = msg.data;
    }

    // 检查是否越界或者障碍物
    bool isValid(const int x, const int y) const
    {
        if (x < 0 || x >= map_width_ || y < 0 || y >= map_height_) return false;
        if (map_data_[y * map_width_ + x] != 0) return false;
        for (auto& obstacle : obstacles_)
        {
            if (x == obstacle.first && y == obstacle.second) return false;
        }
        return true;
    }

    // 使用A*算法从起点搜索到终点，返回路径
    std::vector<Node> searchPath(const Node& start, const Node& goal) const
    {
        std::vector<Node> path;
        std::vector<Node*> closed_set;
        std::priority_queue<Node*, std::vector<Node*>, CompareNodes> open_set;

        // 将起点加入open_set中
        open_set.push(new Node(start.x, start.y, 0, nullptr));

        // 循环搜索直到open_set为空
        while (!open_set.empty())
        {
            Node* current = open_set.top();
            open_set.pop();
            closed_set.push_back(current);

            if (current->x == goal.x && current->y == goal.y)  // 终点节点
            {
                // 反向遍历节点，得到路径
                while (current)
                {
                    path.push_back(*current);
                    current = current->parent;
                }
                std::reverse(path.begin(), path.end());

                // 清空open_set和closed_set
                while (!open_set.empty())
                {
                    delete open_set.top();
                    open_set.pop();
                }
                for (auto& node : closed_set)
                {
                    delete node;
                }
                closed_set.clear();

                return path;
            }

            // 扩展当前节点周围的四个节点
            for (int dx = -1; dx <= 1; dx++)
            {
                for (int dy = -1; dy <= 1; dy++)
                {
                    if (dx == 0 && dy == 0) continue;
                    int x = current->x + dx;
                    int y = current->y + dy;

                    // 检查是否越界或者障碍物
                    if (!isValid(x, y)) continue;

                    // 计算该节点到起点的代价和估计代价
                    double g = current->g + std::sqrt(dx * dx + dy * dy);
                    double f = g + Node::heuristic(new Node(x, y, 0, nullptr), &goal);

                    // 如果该节点已经在closed_set中，则跳过
                    bool in_closed_set = false;
                    for (auto& node : closed_set)
                    {
                        if (node->x == x && node->y == y)
                        {
                            in_closed_set = true;
                            break;
                        }
                    }
                    if (in_closed_set) continue;

                    // 将该节点加入open_set中
                    bool in_open_set = false;
                    Node* node_ptr = nullptr;
                    for (auto& node : open_set)
                    {
                        if (node->x == x && node->y == y)
                        {
                            in_open_set = true;
                            node_ptr = node;
                            break;
                        }
                    }
                    if (!in_open_set)
                    {
                        node_ptr = new Node(x, y, g, current);
                        open_set.push(node_ptr);
                    }
                    else if (g < node_ptr->g)
                    {
                        node_ptr->g = g;
                        node_ptr->f = g + Node::heuristic(node_ptr, &goal);
                        node_ptr->parent = current;
                    }
                }
            }
        }

        // 清空open_set和closed_set
        while (!open_set.empty())
        {
            delete open_set.top();
            open_set.pop();
        }
        for (auto& node : closed_set)
        {
            delete node;
        }
        closed_set.clear();

        return path;
    }

    // 使用贪心算法对路径进行光滑化处理
    std::vector<Node> smoothPath(const std::vector<Node>& path) const
    {
        if (path.size() <= 2) return path;

        std::vector<Node> new_path;
        new_path.push_back(path[0]);
        for (size_t i = 1; i < path.size() - 1; i++)
        {
            const Node& prev = path[i-1];
            const Node& curr = path[i];
            const Node& next = path[i+1];

            double prev_to_curr = std::sqrt(std::pow(prev.x-curr.x, 2) + std::pow(prev.y-curr.y, 2));
            double curr_to_next = std::sqrt(std::pow(curr.x-next.x, 2) + std::pow(curr.y-next.y, 2));
            double prev_to_next = std::sqrt(std::pow(prev.x-next.x, 2) + std::pow(prev.y-next.y, 2));

            // 检查是否三个节点共线
            if (prev_to_curr + curr_to_next == prev_to_next)
            {
                continue;
            }

                        double x1 = curr.x + (prev.x - curr.x) * curr_to_next / prev_to_curr;
            double y1 = curr.y + (prev.y - curr.y) * curr_to_next / prev_to_curr;
            double x2 = curr.x + (next.x - curr.x) * curr_to_next / prev_to_next;
            double y2 = curr.y + (next.y - curr.y) * curr_to_next / prev_to_next;

            // 计算夹角
            double angle = std::atan2(y2 - y1, x2 - x1);

            // 在curr和next之间插入一个新节点
            new_path.push_back(Node(static_cast<int>(std::round(x1)), static_cast<int>(std::round(y1)), 0, nullptr));
            new_path.back().parent = &new_path[new_path.size()-2];
            new_path.push_back(Node(static_cast<int>(std::round(x2)), static_cast<int>(std::round(y2)), 0, nullptr));
            new_path.back().parent = &new_path[new_path.size()-2];
            new_path.back().f = Node::heuristic(&new_path.back(), &new_path.front()) + new_path.back().g;
            new_path.back().f += angle * angle;  // 加上夹角作为代价，用于凸优化

            new_path.push_back(curr);
        }
        new_path.push_back(path.back());

        return new_path;
    }

    // 将路径中的节点转换成实际坐标值
    std::vector<geometry_msgs::PoseStamped> convertPathToPoses(const std::vector<Node>& path) const
    {
        std::vector<geometry_msgs::PoseStamped> poses;
        for (const auto& node : path)
        {
            geometry_msgs::PoseStamped pose;
            pose.pose.position.x = node.x * resolution_ + map_origin_x_;
            pose.pose.position.y = node.y * resolution_ + map_origin_y_;
            pose.pose.orientation = tf::createQuaternionMsgFromYaw(0);
            poses.push_back(pose);
        }
        return poses;
    }

    // 发布路径信息
    void publishPath(const std::vector<Node>& path) const
    {
        nav_msgs::Path path_msg;
        path_msg.header.stamp = ros::Time::now();
        path_msg.header.frame_id = "map";
        path_msg.poses = convertPathToPoses(path);
        path_pub_.publish(path_msg);
    }

    // 执行Hybrid A*路径规划
    void run(const geometry_msgs::PoseStamped& start_pose, const geometry_msgs::PoseStamped& goal_pose)
    {
        Node start(static_cast<int>((start_pose.pose.position.x - map_origin_x_) / resolution_),
                   static_cast<int>((start_pose.pose.position.y - map_origin_y_) / resolution_),
                   0.0, nullptr);

        Node goal(static_cast<int>((goal_pose.pose.position.x - map_origin_x_) / resolution_),
                  static_cast<int>((goal_pose.pose.position.y - map_origin_y_) / resolution_),
                  0.0, nullptr);

        std::vector<Node> path = searchPath(start, goal);
        path = smoothPath(path);
        publishPath(path);
    }

    // 定义节点比较函数，用于优先队列的排序
    struct CompareNodes
    {
        bool operator()(const Node* a, const Node* b) const
        { return a->f > b->f; }
    };
};

int main(int argc, char** argv)
{
    ros::init(argc, argv, "hybrid_astar_planner");

    HybridAstarPlanner planner;

    // 测试：规划一条路径
    geometry_msgs::PoseStamped start_pose;
    start_pose.header.frame_id = "map";
    start_pose.pose.position.x = 1;
    start_pose.pose.position.y = 1;
    start_pose.pose.orientation.w = 1;

    geometry_msgs::PoseStamped goal_pose;
    goal_pose.header.frame_id = "map";
    goal_pose.pose.position.x = 18;
    goal_pose.pose.position.y = 28;
    goal_pose.pose.orientation.w = 1;

    planner.run(start_pose, goal_pose);

    ros::spin();

    return 0;
}
