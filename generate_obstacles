#include <ros/ros.h>
#include <nav_msgs/OccupancyGrid.h>

int obstacle_num_max = 5; // 障碍物数量上限

// 将地图数据中的障碍物信息发布出去的函数
void pub_obstacle_map(nav_msgs::OccupancyGrid map, nav_msgs::OccupancyGrid &obstacle_map,
                      int obstacle_wide, int car_wide, int safe_distance)
{
    int obstacle_num = 0;
    int map_width = map.info.width;
    int map_height = map.info.height;

    while (obstacle_num < obstacle_num_max) {
        int idx = rand() % (map_width * map_height);

        if (obstacle_map.data[idx] != 0) {
            continue; // 如果该位置已经被占据，跳过本次循环
        }

        int x = idx % map_width;
        int y = idx / map_width;

        if (x < 100 || obstacle_wide + car_wide + safe_distance >= std::min(x, map_width - x) ||
            obstacle_wide + car_wide + safe_distance >= std::min(y, map_height - y)) {
            continue; // 不能生成在初始位置或靠近地图边缘
        }

        bool have_at_least_one_neigb_occ = false;

        for (int l = y - obstacle_wide - car_wide - safe_distance;
             l <= y + obstacle_wide + car_wide + safe_distance && !have_at_least_one_neigb_occ; l++) {
            if (l < 0 || l >= map_height) {
                continue;
            }

            for (int m = x - obstacle_wide - car_wide - safe_distance;
                 m <= x + obstacle_wide + car_wide + safe_distance && !have_at_least_one_neigb_occ; m++) {
                if (m < 0 || m >= map_width) {
                    continue;
                }

                if (map.data[l * map_width + m] > 0) {
                    have_at_least_one_neigb_occ = true;
                }
            }
        }

        if (!have_at_least_one_neigb_occ) {
            for (int l = y - obstacle_wide; l <= y + obstacle_wide; l++) {
                for (int m = x - obstacle_wide; m <= x + obstacle_wide; m++) {
                    obstacle_map.data[l * map_width + m] = 100;
                }
            }

            obstacle_num++;
        }
    }
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "obstacle_generator");
    ros::NodeHandle nh;

    int obstacle_wide = 10; // 障碍物宽度
    int car_wide = 1; // 小车宽度
    int safe_distance = 1; // 安全距离

    // 订阅地图信息
    ros::Subscriber sub = nh.subscribe("/map", 1, [&](nav_msgs::OccupancyGrid::ConstPtr map_msg) {
        nav_msgs::OccupancyGrid obstacle_map = *map_msg; // 深拷贝地图数据，以免影响原始数据

        srand(time(0));
        pub_obstacle_map(*map_msg, obstacle_map, obstacle_wide, car_wide, safe_distance);

        // 发布修改后的地图
        ros::Publisher pub = nh.advertise<nav_msgs::OccupancyGrid>("/modified_map", 1);
        obstacle_map.header.stamp = ros::Time::now();
        pub.publish(obstacle_map);
    });

    ros::spin();

    return 0;
}
